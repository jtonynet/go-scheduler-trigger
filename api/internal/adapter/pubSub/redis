package pubSub

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"github.com/jtonynet/go-scheduler-trigger/api/config"
	"github.com/jtonynet/go-scheduler-trigger/api/internal/adapter/database"
	"github.com/jtonynet/go-scheduler-trigger/api/internal/adapter/email"
	"github.com/jtonynet/go-scheduler-trigger/api/internal/core/dto"
	"github.com/redis/go-redis/v9"
)

type RedisPubSub struct {
	client *redis.Client
	pubsub *redis.PubSub

	subscriptions sync.Map
	strategy      string
}

func NewRedisPubSub(cfg config.PubSub) (*RedisPubSub, error) {
	strAddr := fmt.Sprintf("%s:%s", cfg.Host, cfg.Port)

	client := redis.NewClient(&redis.Options{
		Addr:     strAddr,
		Password: cfg.Pass,
		DB:       cfg.DB,
		Protocol: cfg.Protocol,
	})

	rps := &RedisPubSub{
		client:        client,
		strategy:      cfg.Strategy,
		subscriptions: sync.Map{},
	}

	return rps, nil
}

func (r *RedisPubSub) Subscribe(ctx context.Context) {
	// Canal de expiração
	channel := fmt.Sprintf("__keyevent@%s__:expired", os.Getenv("PUBSUB_DB"))
	log.Printf("Escutando expirações no canal: %s", channel)

	// Loop resiliente
	for {
		if err := listenTriggers(ctx, rdb, cacheInMemoDB, channel, mailAdapter); err != nil {
			log.Printf("Erro no listener, reconectando em 2s... err=%v", err)
			time.Sleep(2 * time.Second)
		}
	}

	// return nil
}

func listenTriggers(ctx context.Context, rdb *redis.Client, cacheInMemoDB database.InMemory, channel string, mail *email.Mail) error {
	pubsub := rdb.Subscribe(ctx, channel)

	_, err := pubsub.Receive(ctx)
	if err != nil {
		return fmt.Errorf("erro ao inscrever no canal: %w", err)
	}

	ch := pubsub.Channel()

	for msg := range ch {
		key := msg.Payload // ex: "schedule:8f7a..."

		log.Printf("Chave expirada: %s", key)

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		// Tentar recuperar o valor original
		value, err := cacheInMemoDB.Get(ctx, key)
		if err == redis.Nil {
			log.Printf("Shadow key não encontrada: %s (já removida?)", key)
			continue
		} else if err != nil {
			log.Printf("Erro ao recuperar shadow key (%s): %v", key, err)
			continue
		}

		log.Printf("Payload Recuperado: %s", value)

		// PROCESSAR EVENTO DE NEGÓCIO AQUI --------------------
		processExpiration(key, value, mail)
		// ------------------------------------------------------

		// Remover shadow key após processar
		if err := cacheInMemoDB.Delete(ctx, key); err != nil {
			log.Printf("Erro ao remover shadow key %s: %v", key, err)
		} else {
			log.Printf("Shadow key removida: %s", key)
		}
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	}

	return fmt.Errorf("canal fechado inesperadamente")
}

// Lógica de negócio quando uma chave expira
func processExpiration(key, value string, mail *email.Mail) {
	log.Printf("Processando expiração da chave [%s] com payload: %s", key, value)
	// Aqui vai sua lógica de trigger, scheduler, etc.

	var scheduleDTO dto.SchedulerTriggerReq
	json.Unmarshal([]byte(value), &scheduleDTO)
	mail.Send(
		scheduleDTO.Email,
		"TESTE!",
		scheduleDTO.Message,
	)
}

func mustInt(v string) int {
	var x int
	fmt.Sscan(v, &x)
	return x
}

/////////////////////////////////////////////////////////////////////////////////

func (r *RedisPubSub) UnSubscribe(_ context.Context, key Key) error {
	if transactionsSubscriptions, ok := r.subscriptions.Load(key.Account); ok {
		transactionMap, _ := transactionsSubscriptions.(*sync.Map)

		if subscription, exists := transactionMap.Load(key.Transaction); exists {
			transactionMap.Delete(key.Transaction)
			close(subscription.(chan string))

			hasRemaining := false
			transactionMap.Range(func(_, _ interface{}) bool {
				hasRemaining = true
				return false
			})

			if !hasRemaining {
				r.subscriptions.Delete(key.Account)
			}
		}
	}

	return nil
}

func (r *RedisPubSub) Publish(ctx context.Context, topic, message string) error {
	return r.client.Publish(ctx, topic, message).Err()
}

func (r *RedisPubSub) Close() error {
	if r.pubsub != nil {
		return r.pubsub.Close()
	}
	return nil
}

func (r *RedisPubSub) GetStrategy(_ context.Context) (string, error) {
	return r.strategy, nil
}
